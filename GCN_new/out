WARNING (theano.sandbox.cuda): The cuda backend is deprecated and will be removed in the next release (v0.10).  Please switch to the gpuarray backend. You can get more information about how to switch at this URL:
 https://github.com/Theano/Theano/wiki/Converting-to-the-new-gpu-back-end%28gpuarray%29

WARNING (theano.gof.compilelock): Overriding existing lock by dead process '14952' (I am process '31881')
1 #include <Python.h>
2 #include <iostream>
3 #include "theano_mod_helper.h"
4 #include "cudnn.h"
5 //////////////////////
6 ////  Support Code
7 //////////////////////
8 
9 #if PY_MAJOR_VERSION >= 3
10 #define PyInt_FromLong PyLong_FromLong
11 #endif
12 
13 
14     namespace {
15     struct __struct_compiled_op_3442132e74e76f61361fb1c73112eef4 {
16         PyObject* __ERROR;
17 
18         PyObject* storage_V1;
19         
20 
21         __struct_compiled_op_3442132e74e76f61361fb1c73112eef4() {
22             // This is only somewhat safe because we:
23             //  1) Are not a virtual class
24             //  2) Do not use any virtual classes in the members
25             //  3) Deal with mostly POD and pointers
26 
27             // If this changes, we would have to revise this, but for
28             // now I am tired of chasing segfaults because
29             // initialization code had an error and some pointer has
30             // a junk value.
31             memset(this, 0, sizeof(*this));
32         }
33         ~__struct_compiled_op_3442132e74e76f61361fb1c73112eef4(void) {
34             cleanup();
35         }
36 
37         int init(PyObject* __ERROR, PyObject* storage_V1) {
38             Py_XINCREF(storage_V1);
39             this->storage_V1 = storage_V1;
40             
41 
42 
43             this->__ERROR = __ERROR;
44             return 0;
45         }
46         void cleanup(void) {
47             __label_1:
48 
49 double __DUMMY_1;
50 __label_4:
51 
52 double __DUMMY_4;
53 
54             Py_XDECREF(this->storage_V1);
55         }
56         int run(void) {
57             int __failure = 0;
58             
59     PyObject* py_V1;
60     
61         PyObject* V1;
62         
63 {
64 
65     py_V1 = Py_None;
66     {Py_XINCREF(py_V1);}
67     
68         V1 = NULL;
69         
70 {
71 // Op class DnnVersion
72 
73 #if defined(CUDNN_VERSION)
74 V1 = PyTuple_Pack(2, PyInt_FromLong(CUDNN_VERSION), PyInt_FromLong(cudnnGetVersion()));
75 #else
76 V1 = PyInt_FromLong(-1);
77 #endif
78 __label_3:
79 
80 double __DUMMY_3;
81 
82 }
83 __label_2:
84 
85     if (!__failure) {
86       
87         assert(py_V1->ob_refcnt > 1);
88         Py_DECREF(py_V1);
89         py_V1 = V1 ? V1 : Py_None;
90         Py_INCREF(py_V1);
91         
92       PyObject* old = PyList_GET_ITEM(storage_V1, 0);
93       {Py_XINCREF(py_V1);}
94       PyList_SET_ITEM(storage_V1, 0, py_V1);
95       {Py_XDECREF(old);}
96     }
97     
98         Py_XDECREF(V1);
99         
100     {Py_XDECREF(py_V1);}
101     
102 double __DUMMY_2;
103 
104 }
105 
106             
107         if (__failure) {
108             // When there is a failure, this code puts the exception
109             // in __ERROR.
110             PyObject* err_type = NULL;
111             PyObject* err_msg = NULL;
112             PyObject* err_traceback = NULL;
113             PyErr_Fetch(&err_type, &err_msg, &err_traceback);
114             if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
115             if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
116             if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
117             PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
118             PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
119             PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
120             PyList_SET_ITEM(__ERROR, 0, err_type);
121             PyList_SET_ITEM(__ERROR, 1, err_msg);
122             PyList_SET_ITEM(__ERROR, 2, err_traceback);
123             {Py_XDECREF(old_err_type);}
124             {Py_XDECREF(old_err_msg);}
125             {Py_XDECREF(old_err_traceback);}
126         }
127         // The failure code is returned to index what code block failed.
128         return __failure;
129         
130         }
131     };
132     }
133     
134 
135         static int __struct_compiled_op_3442132e74e76f61361fb1c73112eef4_executor(__struct_compiled_op_3442132e74e76f61361fb1c73112eef4* self) {
136             return self->run();
137         }
138 
139         static void __struct_compiled_op_3442132e74e76f61361fb1c73112eef4_destructor(void* executor, void* self) {
140             delete ((__struct_compiled_op_3442132e74e76f61361fb1c73112eef4*)self);
141         }
142         
143 //////////////////////
144 ////  Functions
145 //////////////////////
146 static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
147   assert(PyTuple_Check(argtuple));
148   if (2 != PyTuple_Size(argtuple)){ 
149      PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 2, got %i", (int)PyTuple_Size(argtuple));
150      return NULL;
151   }
152   __struct_compiled_op_3442132e74e76f61361fb1c73112eef4* struct_ptr = new __struct_compiled_op_3442132e74e76f61361fb1c73112eef4();
153   if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1) ) != 0) {
154     delete struct_ptr;
155     return NULL;
156   }
157   PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_3442132e74e76f61361fb1c73112eef4_executor), struct_ptr, __struct_compiled_op_3442132e74e76f61361fb1c73112eef4_destructor);
158   return thunk; }
159 
160 //////////////////////
161 ////  Module init
162 //////////////////////
163 static PyMethodDef MyMethods[] = {
164 	{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
165 	{NULL, NULL, 0, NULL}
166 };
167 PyMODINIT_FUNC init3442132e74e76f61361fb1c73112eef4(void){
168    (void) Py_InitModule("3442132e74e76f61361fb1c73112eef4", MyMethods);
169 }
170 
===============================
nvcc warning : The 'compute_20', 'sm_20', and 'sm_21' architectures are deprecated, and may be removed in a future release (Use -Wno-deprecated-gpu-targets to suppress warning).
/usr/bin/ld: cannot find -lcudnn
collect2: error: ld returned 1 exit status
Using gpu device 0: GeForce GTX TITAN X (CNMeM is enabled with initial size: 100 MB, cuDNN None)
